/**
 *  Target wrapper to access specific CSRs from com link. This is a very thin
 *  layer to wrap the autogenerated csr classes + native comm layer.
 *
 *  All rights reserved.
 *  Tiny Labs Inc
 *  2020
 */
#ifndef TARGET_H
#define TARGET_H

#include <stdint.h>
#include <stdlib.h>

#include "flexsoc_csr.h"


// Remote stat enum
typedef enum
  {
   SUCCESS     = 0,
   ERR_FAULT   = 1,
   ERR_PARITY  = 2,
   ERR_TIMEOUT = 3,
   ERR_NOMEMAP = 4,
   ERR_UNSUPSZ = 5,
   ERR_UNKNOWN = 7,
  } remote_stat_t;

// Aliasing memory structure
typedef struct {
  uint32_t base;
  uint32_t size;
  uint32_t remap;
} alias_t;

class Target {

  static Target *inst;

private:
  int remote_timeout = 10;
  uint8_t apsel = 0;
  flexsoc_csr *csr;
  Target (char *id);
  
 public:

  // Get singleton instance
  static Target *Ptr (void);
  static Target *Ptr (char *id);

  // Destructor
  virtual ~Target ();

  // General APIs
  void ReadW (uint32_t addr, uint32_t *data, uint32_t cnt);
  void ReadH (uint32_t addr, uint16_t *data, uint32_t cnt);
  void ReadB (uint32_t addr, uint8_t *data, uint32_t cnt);
  void WriteW (uint32_t addr, const uint32_t *data, uint32_t cnt);
  void WriteH (uint32_t addr, const uint16_t *data, uint32_t cnt);
  void WriteB (uint32_t addr, const uint8_t *data, uint32_t cnt);
  uint32_t ReadReg (uint32_t addr);
  void WriteReg (uint32_t addr, uint32_t val);

  // Slave interface
  void SlaveSend (const uint8_t *data, int len);
  void SlaveRegister (void (*cb) (uint8_t *, int));
  void SlaveUnregister (void);
  
  // Trigger IRQ pulse
  void IRQ (uint8_t irq);
  // Set level IRQ
  void IRQSet (uint8_t irq);
  // Clr level IRQ
  void IRQClr (uint8_t irq);
  
  // Access CSRs
  uint32_t FlexsocID (void);
  uint32_t MemoryID (void);
  uint32_t CoreFreq (void);
  void CPUReset (bool reset);
  bool CPUReset (void);
  void SlaveEn (bool en);
  bool SlaveEn (void);

  // Local memory bus aliasing
  int CodeAliasSet (uint8_t idx, alias_t *alias);
  int SysAliasSet (uint8_t idx, alias_t *alias);
  int CodeAliasGet (uint8_t idx, alias_t *alias);
  int SysAliasGet (uint8_t idx, alias_t *alias);
  
  // Remote access
  uint32_t RemoteBase (void);
  void RemoteTimeout (int timeout);
  void RemoteEn (bool en);
  bool RemoteEn (void);
  uint8_t RemoteStat (void);
  const char *RemoteStatStr (void);
  void RemoteClkDiv (uint8_t div);
  uint8_t RemoteClkDiv (void);
  uint32_t RemoteIDCODE (void);
  uint32_t RemoteRegRead (bool APnDP, uint8_t addr);
  void RemoteRegWrite (bool APnDP, uint8_t addr, uint32_t data);
  uint32_t RemoteAPRead (uint8_t addr, uint8_t ap = -1);
  void RemoteAPWrite (uint8_t addr, uint32_t data, uint8_t ap = -1);
  void RemoteAHBAP (uint8_t ap);
  
  // Direct remote memory access (not dependent on bridge mapping)
  uint32_t RemoteReadW (uint32_t addr);
  void RemoteWriteW (uint32_t addr, uint32_t data);
  
  // Remote bridge mapping
  void RemoteAHBEn (bool en);
  void RemoteRemap32M (uint8_t idx, uint32_t remap);
  uint32_t RemoteRemap32M (uint8_t idx);
  void RemoteRemap256M (uint32_t remap);
  uint32_t RemoteRemap256M (void);
};

#endif /* TARGET_H */


